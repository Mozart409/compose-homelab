services:
  searxng:
    container_name: searxng
    ports:
      - "${SEARXNG_PORT}:8080"
    volumes:
      - ${PWD}/searxng:/etc/searxng
    environment:
      - BASE_URL=http://localhost:$SEARXNG_PORT/
      - INSTANCE_NAME=SearxNG
    image: searxng/searxng:latest
    labels:
      - homepage.group=Search
      - homepage.name=SearxNG
      - homepage.icon=emby.png
      - homepage.href=http://searxng.home/
      - homepage.description=Meta search engine
    restart: unless-stopped
  tailscale-pinchflat:
    image: tailscale/tailscale:latest
    container_name: tailscale-pinchflat
    hostname: pinchflat
    environment:
      - "TS_AUTHKEY=${TS_AUTH_KEY}"
      # - "TS_EXTRA_ARGS=--advertise-tags=tag:container"
      - "TS_STATE_DIR=/var/lib/tailscale"
      - "TS_USERSPACE=false"
    volumes:
      - ${PWD}/tailscale-pinchflat/state:/var/lib/tailscale
    devices:
      - /dev/net/tun:/dev/net/tun
    cap_add:
      - net_admin
      - sys_module
    restart: unless-stopped

  pinchflat:
    container_name: pinchflat
    environment:
      - TZ=Europe/Berlin
    # ports:
    #   - ${PINCHFLAT_PORT}:8945
    volumes:
      - ${PWD}/pinchflat/config:/config
      - ${PWD}/pinchflat/downloads:/downloads
    image: ghcr.io/kieraneglin/pinchflat:latest
    restart: unless-stopped
    depends_on:
      - tailscale-pinchflat
    network_mode: service:tailscale-pinchflat

  diun:
    image: crazymax/diun:latest
    container_name: diun
    command: serve
    volumes:
      - "./diun_data:/data"
      - "./diun.yml:/diun.yml:ro"
      - "/var/run/docker.sock:/var/run/docker.sock"
    environment:
      - "TZ=Europe/Berlin"
      - "LOG_LEVEL=info"
      - "LOG_JSON=false"
    labels:
      - "diun.enable=true"
    restart: always

  ntfy:
    image: binwiederhier/ntfy
    container_name: ntfy
    command:
      - serve
    environment:
      - TZ=Europe/Berlin # optional: set desired timezone
    user: 1000:1000 # optional: replace with your own user/group or uid/gid
    volumes:
      - /var/cache/ntfy:/var/cache/ntfy
      - /etc/ntfy:/etc/ntfy
    ports:
      - "${NTFY_PORT}:80"
    healthcheck:
      # optional: remember to adapt the host:port to your environment
      test: [ "CMD-SHELL", "wget -q --tries=1 http://localhost:80/v1/health -O - | grep -Eo '\"healthy\"\\s*:\\s*true' || exit 1" ]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  jellyfin:
    image: lscr.io/linuxserver/jellyfin:latest
    container_name: jellyfin
    depends_on:
      - pinchflat
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Etc/UTC
      - JELLYFIN_PublishedServerUrl=http://$JELLYFIN_HOST}
    volumes:
      - ${PWD}/jellyfin/library:/config
      - ${PWD}/pinchflat/downloads:/data/movies
    ports:
      - ${JELLYFIN_PORT}:8096
      - 8920:8920 #optional
      - 7359:7359/udp #optional
      - 1900:1900/udp #optional
    restart: unless-stopped

  dashy:
    container_name: dashy
    environment:
      - NODE_ENV=production
    ports:
      - ${DASHY_PORT}:8080
    volumes:
      - ${PWD}/dashy-conf.yml:/app/user-data/conf.yml
    restart: unless-stopped
    healthcheck:
      test: [ 'CMD', 'node', '/app/services/healthcheck' ]
      interval: 1m30s
      timeout: 10s
      retries: 3
      start_period: 40s
    image: lissy93/dashy:3.0.1
  open-webui:
    image: ghcr.io/open-webui/open-webui:latest
    container_name: open-webui
    ports:
      - ${OPEN_WEBUI_PORT}:8080
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    volumes:
      - open-webui:/app/backend/data
    restart: unless-stopped

  kestra-postgres:
    image: bitnami/postgresql:17.2.0
    container_name: kestra-postgres
    volumes:
      - kestra-postgres-data:/bitnami/postgresql
    environment:
      POSTGRESQL_DATABASE: kestra
      POSTGRESQL_USERNAME: kestra
      POSTGRESQL_PASSWORD: k3str4
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -d $${POSTGRES_DB} -U $${POSTGRES_USER}" ]
      interval: 30s
      timeout: 10s
      retries: 10

  kestra:
    image: kestra/kestra:latest
    # Note that this setup with a root user is intended for development purpose.
    # Our base image runs without root, but the Docker Compose implementation needs root to access the Docker socket
    # To run Kestra in a rootless mode in production, see: https://kestra.io/docs/installation/podman-compose
    user: "root"
    container_name: kestra
    command: server standalone
    volumes:
      - kestra-data:/app/storage
      - /var/run/docker.sock:/var/run/docker.sock
      - /tmp/kestra-wd:/tmp/kestra-wd
    environment:
      KESTRA_CONFIGURATION: |
        datasources:
          postgres:
            url: jdbc:postgresql://kestra-postgres:5432/kestra
            driverClassName: org.postgresql.Driver
            username: kestra
            password: k3str4
        kestra:
          server:
            basicAuth:
              enabled: false
              username: "admin@kestra.io" # it must be a valid email address
              password: kestra
          repository:
            type: postgres
          storage:
            type: local
            local:
              basePath: "/app/storage"
          queue:
            type: postgres
          tasks:
            tmpDir:
              path: /tmp/kestra-wd/tmp
          url: http://localhost:8080/
    ports:
      - "${KESTRA_PORT}:8080"
    depends_on:
      kestra-postgres:
        condition: service_started

  isaiah:
    image: mosswill/isaiah:latest
    container_name: isaiah
    restart: unless-stopped
    ports:
      - "${ISAIAH_PORT}:80"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    environment:
      SERVER_PORT: "80"
      AUTHENTICATION_SECRET: "password"

volumes:
  open-webui:
    external: true
    name: open-webui
  kestra-postgres-data:
    driver: local
  kestra-data:
    driver: local
